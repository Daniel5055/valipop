package uk.ac.standrews.cs.digitising_scotland.record_classification.datastructures.tokens;

import java.io.IOException;
import java.util.*;

import uk.ac.standrews.cs.digitising_scotland.record_classification.classifiers.IClassifier;
import uk.ac.standrews.cs.digitising_scotland.record_classification.datastructures.Pair;
import uk.ac.standrews.cs.digitising_scotland.record_classification.datastructures.bucket.Bucket;
import uk.ac.standrews.cs.digitising_scotland.record_classification.datastructures.code.Classification;
import uk.ac.standrews.cs.digitising_scotland.record_classification.datastructures.code.Code;
import uk.ac.standrews.cs.digitising_scotland.record_classification.datastructures.records.Record;

/**
 * TODO test! - fraser 8/Oct
 * The Class TokenClassificationCache provides a caching facility to an IClassifier.
 * When getClassification(TokenSet) is called the cached Pair<Code,Double> is returned from the cache or
 * the Pair<Code, Double> is generated by the AbstractClassifier and added to the cache.
 */
public class TokenClassificationCache {

    /** The classification cache. */
    private Map<TokenSet, Pair<Code, Double>> classifications;

    /** The abstract classifier used to populate the cache. */
    private IClassifier classifier;

    /**
     * Instantiates a new token classification cache with the IClassifier specified.
     * The classifier specified will be used to generate all Pair<Code,Double>s in the cache.
     *
     * @param classifier the abstract classifier to use when populating the cache
     */
    public TokenClassificationCache(final IClassifier classifier) {

        classifications = new HashMap<>();
        this.classifier = classifier;
    }

    /**
     * Adds the token set to the cache if not allready present.
     *
     * @param tokenSet the token set to add to the cache
     * @throws IOException Signals that an I/O exception has occurred.
     */
    private void addTokenSet(final TokenSet tokenSet) throws IOException {

        if (classifications.get(tokenSet) == null) {
            Pair<Code, Double> classification = classifier.classify(tokenSet);
            classifications.put(tokenSet, classification);
        }
    }

    /**
     * Gets the classification (Pair<Code, Double> from the cache or generates and adds it to the cache if not already present.
     *
     * @param tokenSet the token set to classify
     * @return the classification Pair<Code, Double>
     * @throws IOException Signals that an I/O exception has occurred.
     */
    public Pair<Code, Double> getClassification(final TokenSet tokenSet) throws IOException {

        addTokenSet(tokenSet);
        return classifications.get(tokenSet);
    }

    /**
     * Add all CodeTriples to the cache.
     * @param setOfCodeTriples Set to add
     */
    public void addAll(final List<Classification> setOfCodeTriples) {

        for (Classification codeTriple : setOfCodeTriples) {
            classifications.put(codeTriple.getTokenSet(), new Pair<Code, Double>(codeTriple.getCode(), codeTriple.getConfidence()));
        }
    }

    public void prePopulate(Bucket cachePopulationBucket) {
        for (Record record : cachePopulationBucket) {
            List<Classification> singles = getSinglyCodedTriples(record);
            addAll(singles);
        }
    }


    /**
     * Gets the singly coded triples, that is codeTriples that have only one coding.
     *
     * @param record the record to get single triples from
     * @return the singly coded triples
     */
    protected List<Classification> getSinglyCodedTriples(final Record record) {

        List<Classification> singles = new ArrayList<>();

        final Set<Classification> goldStandardClassificationSet = record.getGoldStandardClassificationSet();
        for (Classification codeTriple1 : goldStandardClassificationSet) {
            int count = 0;
            for (Classification codeTriple2 : goldStandardClassificationSet) {
                if (codeTriple1.getTokenSet().equals(codeTriple2.getTokenSet())) {
                    count++;
                }
            }
            if (count == 1) {
                singles.add(codeTriple1);
            }
        }

        return singles;
    }

}
