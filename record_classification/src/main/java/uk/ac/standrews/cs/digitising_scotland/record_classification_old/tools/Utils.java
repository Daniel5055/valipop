/*
 * Copyright 2015 Digitising Scotland project:
 * <http://digitisingscotland.cs.st-andrews.ac.uk/>
 *
 * This file is part of the module record_classification.
 *
 * record_classification is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * record_classification is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with record_classification. If not, see
 * <http://www.gnu.org/licenses/>.
 */
package uk.ac.standrews.cs.digitising_scotland.record_classification_old.tools;

import com.google.common.io.Files;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import org.apache.commons.io.output.FileWriterWithEncoding;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import uk.ac.standrews.cs.digitising_scotland.record_classification_old.datastructures.classification.Classification;
import uk.ac.standrews.cs.digitising_scotland.record_classification_old.datastructures.code.Code;
import uk.ac.standrews.cs.digitising_scotland.util.FileManipulation;

import java.io.*;
import java.nio.charset.Charset;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;

/**
 * Utility classes related to writing to files and other often used methods.
 *
 * @author jkc25
 */
public final class Utils {

    private static final Logger LOGGER = LoggerFactory.getLogger(Utils.class);

    private Utils() {

        // private constructor for utility class.
    }

    /**
     * Handles and exceptions or throwables thrown from threads that are handles by a {@link Future} or {@link ExecutorService}.
     * @param futures Collection of executing futures to handle possible exceptions from.
     * @throws InterruptedException if thread is interrupted
     */
    public static void handlePotentialErrors(final Collection<Future<?>> futures) throws InterruptedException {

        for (Future<?> future : futures) {
            try {
                future.get();
            }
            catch (ExecutionException e) {
                Throwable rootException = e.getCause();
                if (rootException != null) {
                    LOGGER.error(rootException.toString(), rootException);
                }

            }
        }
    }

    /**
     * Generates a storage folder name based on the baseDirectory and prefix.
     * Form of storage folder returned is baseDirectory/prefix + (highestFolder+1)
     * for example target/exampleDir1
     *
     * @param baseDirectory the baseDirectory
     * @param prefix        the prefix
     * @return the storage name
     */
    public static File getStorageName(final File baseDirectory, final String prefix) {

        int highest = calculateHighestFolderNumber(baseDirectory, prefix);
        String newName = prefix + highest + 1;
        return new File(newName);
    }

    /**
     * Calculate highest folder number of storage folder as generated by Utils.getStorageName().
     *
     * @param baseDirectory the base directory
     * @param prefix        the prefix
     * @return the int
     */
    private static int calculateHighestFolderNumber(final File baseDirectory, final String prefix) {

        int highest = 0;
        int current = 0;

        File[] files = baseDirectory.listFiles();
        for (int i = 0; i < files.length; i++) {
            if (files[i].getName().startsWith(prefix)) {
                current = Integer.parseInt(files[i].getName().split(prefix)[1]);
                if (current > highest) {
                    highest = current;
                }
            }
        }
        return highest;
    }

    /**
     * Gets the storage name.
     *
     * @param baseDirectory the baseDirectory
     * @param prefix        the prefix
     * @return the storage name
     */
    public static File getLastStorageName(final File baseDirectory, final String prefix) {

        int highest = calculateHighestFolderNumber(baseDirectory, prefix);
        String newName = prefix + highest;
        return new File(newName);
    }

    public static String getExperimentalFolderName(final String baseFolder, final String folderName) {

        // all experimental data stored in folder called experimentX, where X is
        // an integer.
        int highestFolderCount = 0;
        File base = new File(baseFolder);

        if (!base.exists() && !base.mkdirs()) {
            LOGGER.error("Could not create all folders in path " + base + ".\n" + base.getAbsolutePath() + " may already exsists");
        }

        File[] allFiles = base.listFiles();
        for (File file : allFiles) {
            if (file.isDirectory() && file.getName().contains(folderName)) {

                int currentFolder = Integer.parseInt(file.getName().subSequence(10, file.getName().length()).toString());
                if (currentFolder > highestFolderCount) {
                    highestFolderCount = currentFolder;
                }
            }
        }
        highestFolderCount++;
        return baseFolder + "/" + folderName + highestFolderCount;
    }

    /**
     * Move all files in toMove array to toHere locations.
     *
     * @param toMove List of files to move
     * @param toHere where we want the files moved to.
     * @throws IOException Indicates and IO exception has occured
     */
    public static void moveFiles(final File[] toMove, final File toHere) throws IOException {

        for (int i = 0; i < toMove.length; i++) {
            if (toMove[i].exists() && toMove[i].isDirectory()) {
                File newFolder = new File(toHere + "/" + toMove[i].getName());
                if (!newFolder.exists() && !newFolder.mkdirs()) {
                    LOGGER.error("Error creating " + newFolder.getName());
                }
                moveFiles(toMove[i].listFiles(), newFolder);
            }
            else {
                Files.copy(toMove[i], new File(toHere.getAbsolutePath() + "/" + toMove[i].getName()));

            }
        }

    }

    /**
     * Moves the files specified.
     *
     * @param listOfFilesToMove String array of file names to move
     * @param storage           Folder to store files in.
     * @throws IOException IOException
     */
    public static void moveFilesTo(final String[] listOfFilesToMove, final File storage) throws IOException {

        File home = new File(".");
        File[] files = home.listFiles();
        Arrays.sort(files, new Comparator<File>() {

            public int compare(final File f1, final File f2) {

                return Long.valueOf(f1.lastModified()).compareTo(f2.lastModified());
            }
        });

        if (!storage.exists()) {
            LOGGER.error("folder already exists: " + storage.getAbsolutePath());
        }

        if (!storage.mkdirs()) {
            LOGGER.error("Problem creating folder " + storage.getAbsolutePath());
        }

        File[] toMove = new File[listOfFilesToMove.length];

        for (int i = 0; i < listOfFilesToMove.length; i++) {
            toMove[i] = new File(listOfFilesToMove[i]);
        }

        moveFiles(toMove, storage);

        for (int i = 0; i < toMove.length; i++) {
            Utils.deleteDirectory(toMove[i]);
        }

        File[] otherFilesToMove = new File[1];
        File sgdModel = new File("crossFoldModel/crossFoldModel.model");
        otherFilesToMove[0] = sgdModel;
        moveFiles(otherFilesToMove, storage);

    }

    /**
     * Returns a common regex that catchs commas when not surrounded by quotation marks. This is useful for parsing CSV
     * files.
     *
     * @return String regex ",\\s*(?=([^\"]*\"[^\"]*\")*[^\"]*$)"
     */
    public static String getCSVComma() {

        return ",\\s*(?=([^\"]*\"[^\"]*\")*[^\"]*$)";
    }

    /**
     * Writes a string to a file. Can append or overwrite.
     *
     * @param content  String to write.
     * @param fileName Name of file to write to.
     * @param append   Append.
     */
    public static void writeToFile(final String content, final String fileName, final boolean append) {

        FileWriterWithEncoding fstream = null;

        try {
            fstream = new FileWriterWithEncoding(fileName, Charset.forName("UTF-8"), append);
            BufferedWriter out = new BufferedWriter(fstream);
            out.write(content);
            // Close the output stream
            out.flush();
            out.close();
        }
        catch (IOException e) {
            LOGGER.error(e.getMessage(), e);
        }
    }

    /**
     * Writes given string to the given file name. Handles opening and closing of buffered writers etc.
     *
     * @param lloutput output String to be written to file.
     * @param filename the name of the file to write to.
     */
    public static void writeToFile(final String lloutput, final String filename) {

        FileWriterWithEncoding fstream;
        try {
            Files.createParentDirs(new File(filename));
            fstream = new FileWriterWithEncoding(filename, Charset.forName("UTF-8"));
            BufferedWriter out = new BufferedWriter(fstream);
            out.write(lloutput);
            out.flush();
            // Close the output stream
            out.close();
        }
        catch (IOException e) {
            LOGGER.error(e.getMessage(), e);
        }

    }

    /**
     * writes a comma seperated 2D array to file.
     *
     * @param data Date to write.
     * @param name Name of file to write to.
     */
    public static void writeToFile(final int[][] data, final String name) {

        FileWriterWithEncoding fstream;
        try {
            fstream = new FileWriterWithEncoding(name, Charset.forName("UTF-8"), false);
            BufferedWriter out = new BufferedWriter(fstream);

            for (int i = 0; i < data.length; i++) {
                out.write(i + ",");
                for (int j = 0; j < data[i].length; j++) {
                    out.write(data[i][j] + ",");
                }
                out.write("\n");
            }

            // Close the output stream
            out.close();
        }
        catch (IOException e) {

            LOGGER.error(e.getMessage(), e);
        }
    }

    /**
     * Returns the number of lines in a file.
     *
     * @param file the File to read.
     * @return number of lines.
     * @throws IOException Will throw is we can't din the file.
     */
    @SuppressFBWarnings(value = "RV_DONT_JUST_NULL_CHECK_READLINE")
    public static int getNumberOfLines(final File file) throws IOException {

        try (BufferedReader reader = java.nio.file.Files.newBufferedReader(Paths.get(file.getAbsolutePath()), FileManipulation.FILE_CHARSET)) {

            int lines = 0;
            while (reader.readLine() != null) {
                lines++;
            }
            return lines;
        }
    }

    /**
     * Deletes the specified directory.
     *
     * @param directory to delete.
     * @return True is deleted. False if there is a problem.
     */
    public static boolean deleteDirectory(final File directory) {

        try {
            FileManipulation.deleteDirectory(directory.getAbsolutePath());
            return true;
        }
        catch (IOException e) {
            return false;
        }
    }

    /**
     * Count the number of files in a directory.
     *
     * @param dirPath the directory path to count files in
     * @param count   the starting count
     * @return int number of files in directroy
     */
    public static int countFiles(final String dirPath, int count) {

        File f = new File(dirPath);
        File[] files = f.listFiles();

        if (files != null) {
            for (int i = 0; i < files.length; i++) {
                File file = files[i];
                if (file.isDirectory()) {
                    count++;
                    count = countFiles(file.getAbsolutePath(), count);
                }
                else {
                    count++;
                }
            }
        }
        return count;
    }

    /**
     * Sorts a map that implements Comparable from biggest to smallest.
     *
     * @param <K> the key type
     * @param <V> the value type
     * @param map the map
     * @return a sorted map in descending order
     */
    public static <K, V extends Comparable<? super V>> Map<K, V> sortByValueDescending(final Map<K, V> map) {

        List<Map.Entry<K, V>> list = new LinkedList<Map.Entry<K, V>>(map.entrySet());
        Collections.sort(list, new Comparator<Map.Entry<K, V>>() {

            public int compare(final Map.Entry<K, V> o1, final Map.Entry<K, V> o2) {

                return o2.getValue().compareTo(o1.getValue());
            }
        });

        Map<K, V> result = new LinkedHashMap<K, V>();
        for (Map.Entry<K, V> entry : list) {
            result.put(entry.getKey(), entry.getValue());
        }
        return result;
    }

    /**
     * Sorts a map that implements Comparable from biggest to smallest.
     *
     * @param <K> the key type
     * @param <V> the value type
     * @param map the map
     * @return a sorted map in descending order
     */
    public static <K, V extends Comparable<? super V>> Map<K, V> sortByValueAscending(final Map<K, V> map) {

        List<Map.Entry<K, V>> list = new LinkedList<Map.Entry<K, V>>(map.entrySet());
        Collections.sort(list, new Comparator<Map.Entry<K, V>>() {

            public int compare(final Map.Entry<K, V> o1, final Map.Entry<K, V> o2) {

                return o1.getValue().compareTo(o2.getValue());
            }
        });

        Map<K, V> result = new LinkedHashMap<K, V>();
        for (Map.Entry<K, V> entry : list) {
            result.put(entry.getKey(), entry.getValue());
        }
        return result;
    }

    /**
     * Performs a check to make sure that the testing split start position is compatible with the size of the set.
     * Reduces start position if not.
     *
     * @param startPosition    start position
     * @param percentTestFiles size of test split
     * @return start position if OK, new start position if moved.
     */
    public static int checkStartPosition(final int startPosition, final int percentTestFiles) {

        final int fullFile = 100;
        if (startPosition <= (fullFile - percentTestFiles)) {
            return startPosition;
        }
        else {
            return startPosition - startPosition % (fullFile - percentTestFiles);
        }

    }

    /**
     * Closes a reader.
     *
     * @param bufferedReader reader to close.
     */
    public static void closeReader(final BufferedReader bufferedReader) {

        try {
            if (bufferedReader != null) {
                bufferedReader.close();
            }
        }
        catch (IOException e) {
            LOGGER.error(e.getMessage(), e);
        }
    }

    /**
     * Executes the specified string command in a separate process using exec().
     * The output from the command execution is grabbed by a reader and returned after execution.
     * @param command command to execute
     * @return output from command execution
     */
    public static String executeCommand(final String command) {

        StringBuffer output = new StringBuffer();
        Process p;
        try {
            p = Runtime.getRuntime().exec(command);
            int exitVal = p.waitFor();

            try (BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream(), FileManipulation.FILE_CHARSET))) {

                String line;

                while ((line = reader.readLine()) != null) {
                    output.append(line + "\n");
                }
            }

            if (exitVal != 0) {
                LOGGER.debug("ExitValue: " + exitVal);
            }
        }
        catch (Exception e) {
            LOGGER.error(e.getMessage(), e.getCause());
        }

        return output.toString();
    }

    /**
     * Checks if a given code is a member of a set of CodeTriples.
     * @param code to check for
     * @param setCodeTriples to check in
     * @return true if code is a member of the set
     */
    public static boolean contains(final Code code, final Set<Classification> setCodeTriples) {

        for (Classification codeTriple : setCodeTriples) {
            if (codeTriple.getCode().equals(code)) { return true; }
        }
        return false;
    }

    /**
     * Returns the codeTriples from the set where the codeTriple has the given code.
     * @param code to check for
     * @param setCodeTriples to check in
     * @return true if code is a member of the set
     */
    public static Classification getCodeTripleWithCode(final Code code, final Set<Classification> setCodeTriples) {

        for (Classification codeTriple : setCodeTriples) {
            if (codeTriple.getCode().equals(code)) { return codeTriple; }
        }
        return null;
    }

}
