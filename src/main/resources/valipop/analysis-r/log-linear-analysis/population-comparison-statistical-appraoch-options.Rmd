---
title: "Comparing demographic populations using Log Linear Models"
author: "Tom Dalton"
date: "22/02/2017"
output: pdf_document
fontsize: 11pt
geometry: margin=0.5in 
---

_This ideas underlying this approach were first discussed in the meeting on 18/2/2017 between Monique MacKenzie, Graham Kirby and Tom Dalton._

The purpose of this document is to layout the statistical approach to assert the similarity of two demographic populations. The input is taken to be in the form of a contingency table. This contingency table is derived from the simulated population and the set of summary input tables.

# Example data files

Through out we will make use of several different example data files, print outs of these can be seen in _Appendix A_.

```{r}
close <- read.table("fake-pop-close-match.dat", header = T)
wayward <- read.table("fake-pop-wayward.dat", header = T)
```

This is the top of one of these data tables:

```{r}
head(close)
```

Each of the columns hold descriptors of people in the populations and the frequency column indicates how may people in the population have these properties.

The models we talk about are focused on understanding the interactions between all the other columns and how they impact on frequency.

# Approach 1 - Identify if a powerful model exists that does not contain interactions with source

* Here we create a log linear model using all values in a contingency table
* We then select the most parsimonious model based on AIC
* We then consider the interactions in the model
* If no source interactions remain in the selected model and the model exhibits good predictive power then we can conclude that the 'in' and the 'sim' populations can be considered one

```{r results='hide'}
 library("MASS")
  dT <- close
  model.sat = loglm(freq ~ yob * age * sex * died * source, data = dT)
  model.step.result = step(model.sat, direction = "backward")
  model.sel = eval(parse(text=model.step.result["call"]))
  cat("If this below model does not contain any source interactions
        then we can assert that the sim and input populations are of 
        the same specified statistical properties\n")
  model.sel
```

```{r echo = FALSE}
  cat("If the below model does not contain any interactions of source
        then we can assert that the sim and input populations are of 
        the same specified statistical properties\n")
  model.sel
```

We can see here that we have a model with high explanative power (high value of P) which makes no reliance on the variable source in the model. Therefore we can assert that the people derived from the input summary tables and those counted in the simulation population can be seen as originating from the same population.

__Question: is this sufficient to claim that our two populations can be considered to conform to the same summary input properties that we use to inform our simulation?__

We can repeat this with a populations that are a poorer match:

```{r}
  dT <- wayward
```

```{r echo=FALSE, results='hide'}
  model.sat = loglm(freq ~ yob * age * sex * died * source, data = dT)
  model.step.result = step(model.sat, direction = "backward")
  model.sel = eval(parse(text=model.step.result["call"]))
```

```{r}
  model.sel
```

Again we have selected the most parsimonious model which also has strong predictive ability. However, as can be seen the model's formula we see that source interactions are required to create a model that is able to predict well. Therefore we can assert that the two sets of people ('in' and 'sim') are distinctly different and thus say that in this contingency table the two populations do not follow the same input summary data.

_Full code output traces for approach 1 can be seen in appendix B._

# Approach 2 - Train two models and compare

This second approach has been born out of a desire to find a way to perform the comparison and get a singular value that indicates similarity. 

The approach entails:

* Sub-setting the contingency table by source
* We then create a log linear model (excluding source) based on the rows with source 'in'
* And a second model (excluding source) based on the rows with source 'sim'
* We then select the most parsimonious models based on AIC
* We then compare these models

__Question: is there a way to take a meaningful value from this comparison?__


```{r results='hide', warning=FALSE}
  library("MASS")
  d <- close
  d.in = subset(d, source == "in")
  d.sim = subset(d, source == "sim")
  
  model.in.sat = loglm(freq ~ yob * age * sex * died, data = d.in)
  model.in.step.result = step(model.in.sat, direction = "backward")
  model.in.sel = eval(parse(text=model.in.step.result["call"]))
  
  model.sim.sat = loglm(freq ~ yob * age * sex * died, data = d.sim)
  model.sim.step.result = step(model.sim.sat, direction = "backward")
  model.sim.sel = eval(parse(text=model.sim.step.result["call"]))
  
  model.in.sel.glm = glm(model.in.sel, data = d, family = poisson)
  model.sim.sel.glm = glm(model.sim.sel, data = d, family = poisson)
  
```

```{r}
  anova(model.in.sel.glm, model.sim.sel.glm, test = "Chisq")
  AIC(model.in.sel.glm, model.sim.sel.glm)
```


__Question: Here we want to identify if the two models are statistically similar. Is this a legitimate way to do so? Or is there another metric we should investigate?__
__My understanding is that the anova analysis assumes nested models are therefore isn't sutable in this setting. AIC doesn't have this underlying assumption but doesn't seem to yield values that support the findings for the respective datasets under approach 1.__

We can also do this for the wayward population:

```{r}
  d <- wayward
```
 
```{r echo = FALSE, results='hide', warning=FALSE}
  library("MASS")
  d.in = subset(d, source == "in")
  d.sim = subset(d, source == "sim")
  
  model.in.sat = loglm(freq ~ yob * age * sex * died, data = d.in)
  model.in.step.result = step(model.in.sat, direction = "backward")
  model.in.sel = eval(parse(text=model.in.step.result["call"]))
  
  model.sim.sat = loglm(freq ~ yob * age * sex * died, data = d.sim)
  model.sim.step.result = step(model.sim.sat, direction = "backward")
  model.sim.sel = eval(parse(text=model.sim.step.result["call"]))
  
  model.in.sel.glm = glm(model.in.sel, data = d, family = poisson)
  model.sim.sel.glm = glm(model.sim.sel, data = d, family = poisson)
  
```

```{r warning=FALSE}
  anova(model.in.sel.glm, model.sim.sel.glm, test = "Chisq")
  AIC(model.in.sel.glm, model.sim.sel.glm)
```

_Full code output traces can be seen in appendix C for option 2._

\newpage

#Appendix

##A

```{r}
close <- read.table("fake-pop-close-match.dat", header = T)
close

wayward <- read.table("fake-pop-wayward.dat", header = T)
wayward
```


##B

```{r}
 library("MASS")
  dT <- close
  model.sat = loglm(freq ~ yob * age * sex * died * source, data = dT)
  model.step.result = step(model.sat, direction = "backward")
  model.sel = eval(parse(text=model.step.result["call"]))
  cat("If this below model does not contain any source interactions
        then we can assert that the sim and input populations are of 
        the same specified statistical properties\n")
  model.sel
```

***

```{r}
 library("MASS")
  dT <- wayward
  model.sat = loglm(freq ~ yob * age * sex * died * source, data = dT)
  model.step.result = step(model.sat, direction = "backward")
  model.sel = eval(parse(text=model.step.result["call"]))
  cat("If this below model does not contain any source interactions
        then we can assert that the sim and input populations are of 
        the same specified statistical properties\n")
  model.sel
```

# C

```{r}
  library("MASS")
  d <- close
  d.in = subset(d, source == "in")
  d.sim = subset(d, source == "sim")
  
  model.in.sat = loglm(freq ~ yob * age * sex * died, data = d.in)
  model.in.step.result = step(model.in.sat, direction = "backward")
  model.in.sel = eval(parse(text=model.in.step.result["call"]))
  
  model.in.sel
  
  model.sim.sat = loglm(freq ~ yob * age * sex * died, data = d.sim)
  model.sim.step.result = step(model.sim.sat, direction = "backward")
  model.sim.sel = eval(parse(text=model.sim.step.result["call"]))
  
  model.in.sel.glm = glm(model.in.sel, data = d, family = poisson)
  model.sim.sel.glm = glm(model.sim.sel, data = d, family = poisson)
  
  anova(model.in.sel.glm, model.sim.sel.glm, test = "Chisq")
  AIC(model.in.sel.glm, model.sim.sel.glm)
```

***

```{r}
  library("MASS")
  d <- wayward
  d.in = subset(d, source == "in")
  d.sim = subset(d, source == "sim")
  
  model.in.sat = loglm(freq ~ yob * age * sex * died, data = d.in)
  model.in.step.result = step(model.in.sat, direction = "backward")
  model.in.sel = eval(parse(text=model.in.step.result["call"]))
  
  model.in.sel
  
  model.sim.sat = loglm(freq ~ yob * age * sex * died, data = d.sim)
  model.sim.step.result = step(model.sim.sat, direction = "backward")
  model.sim.sel = eval(parse(text=model.sim.step.result["call"]))
  
  model.in.sel.glm = glm(model.in.sel, data = d, family = poisson)
  model.sim.sel.glm = glm(model.sim.sel, data = d, family = poisson)
  
  anova(model.in.sel.glm, model.sim.sel.glm, test = "Chisq")
  AIC(model.in.sel.glm, model.sim.sel.glm)
```
