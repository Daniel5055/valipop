
# Legacy Code

**University of St Andrews**

*Date*

## Abstract

- 250 words

## Declaration

I declare that the material submitted for assessment is my
own work except where credit is explicitly given to others by
citation or acknowledgement. This work was performed
during the current academic year except where otherwise
stated.
The main text of this project report is [insert word count]
words long, including project specification and plan.
Declaration
In submitting this project report to the University of St
Andrews, I give permission for it to be made available for use
in accordance with the regulations of the University Library.
I also give permission for the title and abstract to be
published and for copies of the report to be made and
supplied at cost to any bona fide library or research worker,
and to be made available on the World Wide Web. I retain
the copyright in this work.

## Contents page

## Introduction

## Context Survey

### ValiPop

ValiPop is a program for simulating synthetic genealogical populations from a collection of desired statistics. It also validates that the simulated population conforms to the desired statistics and writes out the population as series of birth, death, and marriage records.

ValiPop was developed as a part of Dr. Tom Dalton's PH.D. at the University of St Andrews, under the supervision of Dr. Graham Kirby and Prof. Alan Dearle. His thesis focused on evaluating data linkage algorithms using synthetic population records generated by ValiPop.

Data linkage refers the process of identifying records which refer to the same individual across multiple different datasets (site). It can be used practically to construct a single cohesive population from multiple separate datasets.

To evaluate the data linkage algorithms in Dr. Dalton's thesis, the synthetic population records generated by ValiPop were be passed to a program which partly corrupts the records, simulating the random error present in historical records. The population reconstructed by the data linkage algorithms was then compared with the true population to determine its performance.

Dr. Dalton completed his thesis in 2022 and the final commit to ValiPop was made in early 2023. However, as ValiPop was developed to be used in Dr. Dalton's thesis, it was not easily accessible or usable for general users. Eventually, ValiPop no longer compiled due to broken dependencies by late 2024.

## Requirements Specification

This chapter lists the original requirements as documented in the Description, Objectives, Ethics & Resources (DOER) document submitted in the first semester. To differentiate between ValiPop before and after my dissertation work, I will refer to the ValiPop version before my dissertation as the *old ValiPop*

### Primary

1. **Pruning old data**. The old ValiPop repository is closely related to the Ph.D. thesis it was developed with, containing many data files and results not relevant to a general user. The sample statistics provided by the repository should also be checked to have open licenses to avoid ethical concerns.

2. **Decoupling the software from hardware**. The old ValiPop program is tightly coupled to the local machine Dr. Dalton developed it with. It contains hardcoded paths, incompatible file names, and scripts not usable without Shell, which all should be modified to support users running ValiPop on any machine.

3. **Creating a documented, single build artefact**. Several undocumented steps are required to run the old ValiPop program. Ideally, the user should be able to run ValiPop through a single, well-documented interface. ValiPop should also have additional documentation on its configuration, results, and development. 

4. **Expanding the testing**. The old ValiPop tests are no longer functional, and should be repaired and expanded to cover both the simulation and validation processes of ValiPop.

5. **Restoring the simulation source code**. Some features such as exporting populations to different file formats are invoked in tests but not callable by the user in the old ValiPop. These features should be restored and made accessible to users, and any existing bugs in the old ValiPop generally should be resolved also. 

### Secondary

6. **Offering the build artefact**. In the old ValiPop, users must clone, compile and execute the program to run it. Ideally, users should be able to download a pre-compiled artefact to run ValiPop easily.

7. **Support additional output formats**. In the old ValiPop, the generated population can be represented as records in tabular form, or potentially in some graph formats like GEDCOM. Adding additional formats for ValiPop to represent a population as would be a useful feature to make it more accessible.

8. **Rewriting the validation code**. Whilst the Old ValiPop simulation code is written in Java, the validation code is written separately in R. This complicates the maintenance and execution of the program, and ideally the validation should be rewritten to Java.

9. **Expanding the population simulation**. This entails adding additional features to the populations simulation of the old ValiPop, such as more customisable parameters for the populations.

10. **Improve the program interface**. The old ValiPop can only be interacted with through invoking the necessary commands in a terminal. Creating a simple terminal or graphical user interface would help less technical users interact with the program more easily.

## Software Engineering Approach

This project is not a typical software development project as it focuses on restoring existing legacy code as opposed to developing my own software from scratch. Therefore, I took a more cautious approach when working on ValiPop as it was critical that the existing functionality was preserved. Consequently, my approach was divided into several steps which started small but were gradually built up.

### Study the code

The first step was to determine the state of the old ValiPop program and identify how it operated. The existing documentation included with the old ValiPop seemed out-of-date, so I resulted to reading through the source code to gather an understanding of the execution flow. Reading Dr. Dalton's thesis also provided insight into many features of the old ValiPop such as the options supported during execution. Once I had a rudimentary understanding of the program, I met with Dr. Dalton in-person to clarify additional details such as the statistics behind the population validation.

- Understanding the code base
    - Identifying how the software operated
    - What worked and what didn't
    - Asking questions to PHD student
    - Documenting code as I read through it

### Execute the program

Once I had a decent understanding of the old ValiPop, I attempted to execute the program. This included identifying and installing the necessary dependencies, modifying the source code to support execution on my machine, and fixing any errors that occurred during the process. With each attempt at running ValiPop, I needed to ensure the generated population was validated and written to records correctly.

- Executing the program
    - Adjusting parameters and paths to work for my machine
    - Fixing any immediate errors that occur during execution
    - Ensuring the results are correct

### Simplify execution

After successful running ValiPop on my machine, I proceeded to work on making it more easily executable. I identified and removed unnecessary dependencies, as well as created a virtual environment to aid in installing the R dependencies. I additionally replaced hard-coded file paths with configurable paths, eventually being able to build and execute ValiPop on any Unix-like machine in a few steps.

To support running ValiPop on other operating systems like Windows, I later containerised the compilation and execution of ValiPop. Eventually, I was also able to integrate the external scripts used by ValiPop, allowing for it to run locally on Windows also.

- Simplifying execution
    - Supporting execution on any machine
    - Containerisation and virtual environments
    - Reducing the number of necessary dependencies
        - Removing unncessary R packages
        - Removing shell scripts and external scripts

### Simplify development

Once I could execute ValiPop more easily, I focused on restoring the testing. The tests were initially broken for the old ValiPop, however I managed to recover them by fixing the problematic dependencies. Once restored, I implemented end-to-end tests which ensured ValiPop returned the same output given some input. This then allowed me to refactor and simplify sections of ValiPop whilst guaranteeing the same functionality.

- Simplyifing development
    - Additional tests
        - End to end tests to ensure changes do not lead to inconsitency
    - Refactoring complex sections

### Integrate features

With some additional testing established, I then worked on integrating additional features which improve the user experience of ValiPop. This included integrating the additional output formats, like GEDCOM which was already implemented, into the main program to be accessible by the user. I also added additional error handling when reading input to help users identify mistakes in their input configurations. Notably, whilst implementing error handling, I identified and fixed several bugs caused by unusual configuration options.

- Fixing and integrating features
    - Fixing bugs that occur with specific configurations
    - Integrating features developed but not added to the main program.

- May talk about factor search here

### Documentation

Throughout my software engineering approach, I wrote documentation about ValiPop. Whilst studying the code of the old ValiPop, I documented what I learned in the form of JavaDoc. I also hosted additional documentation from the Github repository, detailing the steps to compile and execute ValiPop both locally and with a container. To document the configuration options, input statistics, and results, I included reference sheets in the hosted documentation which explain each aspect briefly.

To support the future development of ValiPop, I also wrote documentation explaining how each section of ValiPop operates and how each input is used internally.

- Improving performance
    - Analysis of memory usage using Spark
    - Reducing the memory footprint

## Ethics

The genealogical populations generated by ValiPop are completely fabricated based on the input statistics provided, and do not reflect any real families or individuals. The input statistics provided by the ValiPop repository should also be publicly available to use and redistribute. Therefore, I believe this project did not raise any ethical issues and I completed a preliminary ethics self-assessment form to confirm this.

However, upon examining the input statistics included with the old ValiPop, I identified six statistics which did not allow redistribution or public usage. Three distributions providing probabilities for historical British forenames and surnames were retrieved from the North Atlantic Population Project (NAPP), which grants a limited license which prevent redistributing the data (site). The remaining three distributions provided probabilities for Dominican forenames and Spanish surnames and appeared to be from the parenting websites parenting.firstcry.com and familyeducation.com. However, both websites specify in their terms of use that the materials are copyrighted (site).

To ensure the ValiPop repository only included open and redistributable data, I removed all instances of these statistics from the git commit history. The forename statistics were then replaced with open data retrieved from the Office for National Statistics (ONS), and the surnames statistics were replaced with data retrieved from the National Records of Scotland (NRS). Moreover, I included a file correctly citing and referencing the usage rights of each source among all the input statistics at `src/main/resources/inputs/usage.md`.

- No ethics, attach sheet
- Worth mentioning the existing data is open and free use

## Design

- How the project is designed already
    - Population in simulation
    - R analysis
        - How this is unusual
    - Result recording
    - Emphasis on the complexity of legacy code, and why total refactoring or rewriting is not feasable
- Clarify the design represents how I planned to improve the legacy code
    - Need to extract local references from the project
    - Make it easy executable
        - Virtualising R
        - Consider using Renjin
        - Settling to storing and executing scripts packaged within the jar
    - Make it easily distributable
        - Considered shipping versions with a scripts to run the program
        - Instead reducing the dependencies and shipping the program directly
    - Make the interface simple
    - Add the clear and in-depth documentation

## Implementation

- Details on how I handled the R packages and virtual environment
- How I containerised the project and identified the necessary dependencies
    - How I used and Spark to support distributed factor searching
- How I specifically repaired tests and added e2e tests
    - How the e2e tests ensure my changes do not change the functionality
- How I integrated the R calling and analysis scripts directly into Java
- How I refactored certain sections and why they were necessary
- The specific steps I took to reduce memory usage

## Evaluation

- I underestimated the difficulty to tackling an existing complex project
    - The more I read through the software, the more I saw how complex sections were than what I originally thought
- Recognising the unusual goal of this disseration
    - Did I have a good approach for tackling the legacy code
    - I feel like my engineering process worked well
    - Altough I also felt like I initially spent too much time reading through the source code
        - And that I should tried experimenting more with execution and parameters to understand how it worked from a blackbox view
- Could I have simplified execution through other methods?
    - Considering the time spent and difficulty of containerising
- I felt like I could have added additional features to the simulation
    - However I also felt that there were also too many aspects left unfinished
    - And how those needed to be polished first
- Should I compare my work to other projects?

## Conclusion

## Appendix

### Testing Summary

- Mentioned in my implementation
- Go into specifics of how my tests exactly confirm correctness?

### User Manual

- Link to documentation, or include documentation here

### Git Diff

- Perhaps some light commentary on some of the diffed sections
