
# Legacy Code

**University of St Andrews**

*Date*

## Abstract

- 250 words

## Declaration

I declare that the material submitted for assessment is my
own work except where credit is explicitly given to others by
citation or acknowledgement. This work was performed
during the current academic year except where otherwise
stated.
The main text of this project report is [insert word count]
words long, including project specification and plan.
Declaration
In submitting this project report to the University of St
Andrews, I give permission for it to be made available for use
in accordance with the regulations of the University Library.
I also give permission for the title and abstract to be
published and for copies of the report to be made and
supplied at cost to any bona fide library or research worker,
and to be made available on the World Wide Web. I retain
the copyright in this work.

## Contents page

## Introduction

## Context Survey

### ValiPop

ValiPop is a program for simulating synthetic genealogical populations from a collection of desired statistics. It also validates that the simulated population conforms to the desired statistics and writes out the population as series of birth, death, and marriage records.

ValiPop was developed as a part of Dr. Tom Dalton's PH.D. at the University of St Andrews, under the supervision of Dr. Graham Kirby and Prof. Alan Dearle. His thesis focused on evaluating data linkage algorithms using synthetic population records generated by ValiPop.

Data linkage refers the process of identifying records which refer to the same individual across multiple different datasets (site). It can be used practically to construct a single cohesive population from multiple separate datasets.

To evaluate the data linkage algorithms in Dr. Dalton's thesis, the synthetic population records generated by ValiPop were be passed to a program which partly corrupts the records, simulating the random error present in historical records. The population reconstructed by the data linkage algorithms was then compared with the true population to determine its performance.

Dr. Dalton completed his thesis in 2022 and the final commit to ValiPop was made in early 2023. However, as ValiPop was developed to be used in Dr. Dalton's thesis, it was not easily accessible or usable for general users. Eventually, ValiPop no longer compiled due to broken dependencies by late 2024.

## Requirements Specification

This chapter lists the original requirements as documented in the Description, Objectives, Ethics & Resources (DOER) document submitted in the first semester. To differentiate between ValiPop before and after my dissertation work, I will refer to the ValiPop version before my dissertation as the *old ValiPop*

### Primary

1. **Pruning old data**. The old ValiPop repository is closely related to the Ph.D. thesis it was developed with, containing many data files and results not relevant to a general user. The sample statistics provided by the repository should also be checked to have open licenses to avoid ethical concerns.

2. **Decoupling the software from hardware**. The old ValiPop program is tightly coupled to the local machine Dr. Dalton developed it with. It contains hardcoded paths, incompatible file names, and scripts not usable without Shell, which all should be modified to support users running ValiPop on any machine.

3. **Creating a documented, single build artefact**. Several undocumented steps are required to run the old ValiPop program. Ideally, the user should be able to run ValiPop through a single, well-documented interface. ValiPop should also have additional documentation on its configuration, results, and development. 

4. **Expanding the testing**. The old ValiPop tests are no longer functional, and should be repaired and expanded to cover both the simulation and validation processes of ValiPop.

5. **Restoring the simulation source code**. Some features such as exporting populations to different file formats are invoked in tests but not callable by the user in the old ValiPop. These features should be restored and made accessible to users, and any existing bugs in the old ValiPop generally should be resolved also. 

### Secondary

6. **Offering the build artefact**. In the old ValiPop, users must clone, compile and execute the program to run it. Ideally, users should be able to download a pre-compiled artefact to run ValiPop easily.

7. **Support additional output formats**. In the old ValiPop, the generated population can be represented as records in tabular form, or potentially in some graph formats like GEDCOM. Adding additional formats for ValiPop to represent a population as would be a useful feature to make it more accessible.

8. **Rewriting the validation code**. Whilst the Old ValiPop simulation code is written in Java, the validation code is written separately in R. This complicates the maintenance and execution of the program, and ideally the validation should be rewritten to Java.

9. **Expanding the population simulation**. This entails adding additional features to the populations simulation of the old ValiPop, such as more customisable parameters for the populations.

10. **Improve the program interface**. The old ValiPop can only be interacted with through invoking the necessary commands in a terminal. Creating a simple terminal or graphical user interface would help less technical users interact with the program more easily.

## Software Engineering Approach

This project is not a typical software development project as it focuses on restoring existing legacy code as opposed to developing my own software from scratch. Therefore, I took a more cautious approach when working on ValiPop as it was critical that the existing functionality was preserved. Consequently, my approach was divided into several steps which started small but were gradually built up.

### Study the code

The first step was to determine the state of the old ValiPop program and identify how it operated. The existing documentation included with the old ValiPop seemed out-of-date, so I resulted to reading through the source code to gather an understanding of the execution flow. Reading Dr. Dalton's thesis also provided insight into many features of the old ValiPop such as the options supported during execution. Once I had a rudimentary understanding of the program, I met with Dr. Dalton in-person to clarify additional details such as the statistics behind the population validation.

### Execute the program

Once I had a decent understanding of the workings of the old ValiPop, I began modifying sections of the code to make it runnable on my machine.

### Simplify execution

### Simplify development

### Integrate features

### Documentation

- Understanding the code base
    - Identifying how the software operated
    - What worked and what didn't
    - Asking questions to PHD student
    - Documenting code as I read through it
- Executing the program
    - Adjusting parameters and paths to work for my machine
    - Fixing any immediate errors that occur during execution
    - Ensuring the results are correct
- Simplifying execution
    - Supporting execution on any machine
    - Containerisation and virtual environments
    - Reducing the number of necessary dependencies
        - Removing unncessary R packages
        - Removing shell scripts and external scripts
- Simplyifing development
    - Additional tests
        - End to end tests to ensure changes do not lead to inconsitency
    - Refactoring complex sections
- Fixing and integrating features
    - Fixing bugs that occur with specific configurations
    - Integrating features developed but not added to the main program.
- Improving performance
    - Analysis of memory usage using Spark
    - Reducing the memory footprint

## Ethics

- No ethics, attach sheet
- Worth mentioning the existing data is open and free use

## Design

- How the project is designed already
    - Population in simulation
    - R analysis
        - How this is unusual
    - Result recording
    - Emphasis on the complexity of legacy code, and why total refactoring or rewriting is not feasable
- Clarify the design represents how I planned to improve the legacy code
    - Need to extract local references from the project
    - Make it easy executable
        - Virtualising R
        - Consider using Renjin
        - Settling to storing and executing scripts packaged within the jar
    - Make it easily distributable
        - Considered shipping versions with a scripts to run the program
        - Instead reducing the dependencies and shipping the program directly
    - Make the interface simple
    - Add the clear and in-depth documentation

## Implementation

- Details on how I handled the R packages and virtual environment
- How I containerised the project and identified the necessary dependencies
    - How I used and Spark to support distributed factor searching
- How I specifically repaired tests and added e2e tests
    - How the e2e tests ensure my changes do not change the functionality
- How I integrated the R calling and analysis scripts directly into Java
- How I refactored certain sections and why they were necessary
- The specific steps I took to reduce memory usage

## Evaluation

- I underestimated the difficulty to tackling an existing complex project
    - The more I read through the software, the more I saw how complex sections were than what I originally thought
- Recognising the unusual goal of this disseration
    - Did I have a good approach for tackling the legacy code
    - I feel like my engineering process worked well
    - Altough I also felt like I initially spent too much time reading through the source code
        - And that I should tried experimenting more with execution and parameters to understand how it worked from a blackbox view
- Could I have simplified execution through other methods?
    - Considering the time spent and difficulty of containerising
- I felt like I could have added additional features to the simulation
    - However I also felt that there were also too many aspects left unfinished
    - And how those needed to be polished first
- Should I compare my work to other projects?

## Conclusion

## Appendix

### Testing Summary

- Mentioned in my implementation
- Go into specifics of how my tests exactly confirm correctness?

### User Manual

- Link to documentation, or include documentation here

### Git Diff

- Perhaps some light commentary on some of the diffed sections
